"""Markdown to HTML Converter Module for ClaudeAIPanel"""

import os
import re
import sys
import logging
import threading
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import queue
import traceback
from datetime import datetime
import shutil
import json
from typing import Dict, Any, List, Optional

# Import markdown library for conversion
try:
    import markdown
except ImportError:
    logging.error("markdown library not found, attempting to install it")
    import subprocess
    subprocess.run([sys.executable, "-m", "pip", "install", "markdown"])
    import markdown

# Get logger
logger = logging.getLogger("output_library_editor")


class LoggingHandler(logging.Handler):
    """Custom logging handler that redirects logs to the GUI"""
    
    def __init__(self, text_widget):
        logging.Handler.__init__(self)
        self.text_widget = text_widget
        self.log_queue = queue.Queue()
        self.text_widget.after(100, self.poll_log_queue)
    
    def emit(self, record):
        self.log_queue.put(record)
    
    def poll_log_queue(self):
        """Check for new log records and display them"""
        try:
            while True:
                record = self.log_queue.get_nowait()
                self.text_widget.configure(state="normal")
                self.text_widget.insert("end", self.format(record) + "\n")
                self.text_widget.see("end")
                self.text_widget.configure(state="disabled")
                self.text_widget.update_idletasks()
                self.log_queue.task_done()
        except queue.Empty:
            pass
        self.text_widget.after(100, self.poll_log_queue)


def markdown_to_html(markdown_content: str) -> str:
    """
    Convert Markdown to basic HTML suitable for LMS paste-in with proper paragraph spacing
    and special elements support
    
    Special syntax:
    - Use '---stopandreflect---' and '---stopandreflectEND---' markers to create a Stop and Reflect box.
      All content between these markers will be included in the box.
    - Use '---keytakeaways---' and '---keytakeawaysEND---' markers to create a Key Takeaways section
      with red/crimson styling.
    - Learning Objectives: The first H1, H2 titled 'Learning Objectives', and content up to 3 bullet points 
      will be automatically styled in red/crimson.
    
    Args:
        markdown_content: Markdown content to convert
        
    Returns:
        HTML content with proper paragraph breaks and special elements
    """
    # First, normalize line endings
    normalized_content = markdown_content.replace('\r\n', '\n')
    
    # Extract special content before markdown processing
    processed_content, special_sections = extract_special_sections(normalized_content)
    
    # Convert the processed markdown to HTML using the library
    md = markdown.Markdown(extensions=['tables', 'fenced_code', 'extra'])
    html_content = md.convert(processed_content)
    
    # Replace placeholders with formatted special sections
    for placeholder, section_type, content in special_sections:
        if section_type == 'stopandreflect':
            replacement_html = create_stop_reflect_html(content)
        elif section_type == 'keytakeaways':
            replacement_html = create_key_takeaways_html(content)
        else:
            # Skip unknown section types
            continue
            
        html_content = html_content.replace(placeholder, replacement_html)
    
    # Apply color to h1 headings
    html_content = html_content.replace('<h1>', '<h1 style="color:#910204;">')
    
    # Apply automatic styling to Learning Objectives section
    html_content = apply_learning_objectives_styling(html_content)
    
    # Wrap in a container div with styling similar to the test output
    html_content = f'''<div class="container" style="margin:auto;max-width:750px;padding-bottom:4em;padding-left:1em;padding-right:1em;">
    {html_content}
</div>'''
    
    return html_content


def apply_learning_objectives_styling(html_content):
    """
    Automatically apply red styling to the Learning Objectives section
    (First H2 'Learning Objectives' and content up to 3 bullet points)
    
    Args:
        html_content: The HTML content to style
        
    Returns:
        HTML content with Learning Objectives styling
    """
    # Find the Learning Objectives section - match only up to but not including the next heading
    learning_obj_pattern = r'(<h2>\s*Learning Objectives\s*</h2>[\s\S]*?)(?=<h\d>|$)'
    match = re.search(learning_obj_pattern, html_content)
    
    if not match:
        return html_content
    
    # Get the Learning Objectives section content
    section = match.group(1)
    
    # Style the heading
    styled_section = re.sub(r'<h2>\s*Learning Objectives\s*</h2>', 
                         '<h2><span style="color:hsl(359,97%,29%);">Learning Objectives</span></h2>', 
                         section)
    
    # Find paragraphs and style them
    styled_section = re.sub(r'<p>(.*?)</p>', 
                         r'<p><span style="color:hsl(359,97%,29%);">\1</span></p>', 
                         styled_section)
    
    # Find bullet points (up to 3)
    bullet_pattern = r'<li>(.*?)</li>'
    bullet_matches = list(re.finditer(bullet_pattern, styled_section))
    
    # Style up to 3 bullet points
    for i, bullet_match in enumerate(bullet_matches[:3]):
        bullet_text = bullet_match.group(1)
        styled_bullet = f'<li><span style="color:hsl(359,97%,29%);">{ bullet_text }</span></li>'
        styled_section = styled_section.replace(bullet_match.group(0), styled_bullet)
    
    # Replace the original section with the styled version
    html_content = html_content.replace(section, styled_section)
    
    return html_content


def extract_special_sections(content):
    """
    Extract special sections from markdown content and replace with placeholders
    
    Args:
        content: Original markdown content
        
    Returns:
        Tuple of (processed_content, list of tuples (placeholder, section_type, section_content))
    """
    processed_content = content
    special_sections = []
    
    # Extract Stop and Reflect sections
    stop_reflect_pattern = r'---stopandreflect---(.*?)---stopandreflectEND---'
    matches = re.findall(stop_reflect_pattern, processed_content, re.DOTALL)
    
    for i, match in enumerate(matches):
        placeholder = f"SPECIAL_PLACEHOLDER_SR_{i}"
        special_sections.append((placeholder, 'stopandreflect', match.strip()))
        
        # Replace in the content
        section = f"---stopandreflect---{match}---stopandreflectEND---"
        processed_content = processed_content.replace(section, placeholder)
    
    # Extract Key Takeaways sections
    key_takeaways_pattern = r'---keytakeaways---(.*?)---keytakeawaysEND---'
    matches = re.findall(key_takeaways_pattern, processed_content, re.DOTALL)
    
    for i, match in enumerate(matches):
        placeholder = f"SPECIAL_PLACEHOLDER_KT_{i}"
        special_sections.append((placeholder, 'keytakeaways', match.strip()))
        
        # Replace in the content
        section = f"---keytakeaways---{match}---keytakeawaysEND---"
        processed_content = processed_content.replace(section, placeholder)
    
    return processed_content, special_sections


def create_stop_reflect_html(content):
    """
    Create HTML for Stop and Reflect sections
    
    Args:
        content: The markdown content of the section
        
    Returns:
        Formatted HTML
    """
    # Convert the reflection text to HTML
    reflection_md = markdown.Markdown(extensions=['tables', 'fenced_code', 'extra'])
    reflection_html = reflection_md.convert(content)
    
    # Preserve line breaks but remove extra paragraph spacing
    # First, check if we end with a </p> and remove it
    if reflection_html.endswith('</p>'):
        reflection_html = reflection_html[:-4]
        
    # Replace paragraph tags with line breaks, but handle the last one carefully
    reflection_html = reflection_html.replace('<p>', '').replace('</p>', '<br>')
    
    # Remove any trailing <br> that might have been added
    if reflection_html.endswith('<br>'):
        reflection_html = reflection_html[:-4]
    
    # Create the Stop and Reflect box HTML - matched to test output format
    stop_reflect_html = f'''<div class="stop-reflect-container" style="border:3px dashed #e50200; margin:20px 0; padding:0; display:flex; width:100%;">
    <div class="stop-reflect-image" style="width:20%; min-width:100px; display:flex; align-items:center; justify-content:center; padding:10px;">
        <img src="https://api.learnstage.com/media-manager/api/access/exceled/default/lms/courses/1647/Images/Untitled%20design.jpg" 
             style="width:100%; height:auto; max-width:150px;" alt="Stop and Reflect">
    </div>
    <div class="stop-reflect-content" style="display:flex; flex-direction:column; justify-content:center; padding:15px; width:80%;">
        <p>{reflection_html}</p>
    </div>
</div>'''
    
    return stop_reflect_html


def create_key_takeaways_html(content):
    """
    Create HTML for Key Takeaways sections with red/crimson styling
    
    Args:
        content: The markdown content of the section
        
    Returns:
        Formatted HTML
    """
    # Convert the key takeaways to HTML
    takeaways_md = markdown.Markdown(extensions=['tables', 'fenced_code', 'extra'])
    takeaways_html = takeaways_md.convert(content)
    
    # Remove the "Key Takeaways" heading if it exists - it will be part of the template
    if '<h2>Key Takeaways</h2>' in takeaways_html:
        takeaways_html = takeaways_html.replace('<h2>Key Takeaways</h2>', '')
    
    # Create the formatted table structure with image based on the test output
    key_takeaways_html = f'''<figure class="table" style="float:left;width:92.41%;">
    <table class="ck-table-resized" style="border-style:none;">
        <colgroup><col style="width:13.29%;"><col style="width:86.71%;"></colgroup>
        <tbody>
            <tr>
                <td style="border-style:none;">
                    <figure class="image image_resized" style="width:100%;">
                        <img style="aspect-ratio:600/600;" src="https://api.learnstage.com/media-manager/api/access/exceled/default/89309a11-e6ae-4133-97a9-93c735f38be4/content-page/4e85aa67-83db-423a-b7de-53b356164071_removalai_preview.png" width="600" height="600">
                    </figure>
                </td>
                <td style="border-style:none;">
                    <h3>
                        <span style="color:hsl(359,97%,29%);"><strong>Key Takeaways</strong></span>
                    </h3>
                    {takeaways_html}
                </td>
            </tr>
        </tbody>
    </table>
</figure>'''
    
    return key_takeaways_html


class MarkdownConverterPanel:
    """Handles markdown to HTML conversion for the ClaudeAIPanel."""
    
    def __init__(self, parent):
        """
        Initialize the markdown converter panel.
        
        Args:
            parent: The parent ClaudeAIPanel instance
        """
        self.parent = parent
        self.is_converting = False
        self.files_to_convert = []
        self.output_dir = None
        self.conversion_thread = None
    
    def setup_converter_tab(self):
        """Set up the markdown to HTML converter tab."""
        tab = self.parent.md_to_html_tab
        
        # Main frame for all controls
        main_frame = ttk.Frame(tab, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title label
        title_label = ttk.Label(main_frame, text="Batch Markdown to HTML Converter", font=("Arial", 12, "bold"))
        title_label.pack(pady=(10, 15))
        
        # Configuration frame
        config_frame = ttk.LabelFrame(main_frame, text="Conversion Settings", padding=10)
        config_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Info note about Learning Objectives formatting
        info_frame = ttk.Frame(config_frame, style="InfoFrame.TFrame")
        info_frame.pack(fill=tk.X, padx=5, pady=5)
        
        info_label = ttk.Label(info_frame, 
                          text="Note: The converter will automatically apply red styling to H1 headings, "
                               "the 'Learning Objectives' heading, and content up to the first 3 bullet points.", 
                          wraplength=550, justify="left")
        info_label.pack(anchor="w", padx=5, pady=5)
        
        # Instructions
        instructions = ttk.Label(config_frame, 
                           text="Select markdown files in the library panel and use the 'Convert Selected Files' button below.")
        instructions.pack(anchor="w", padx=5, pady=5)
        
        # File count status
        self.file_count_label = ttk.Label(config_frame, text="0 files selected for conversion")
        self.file_count_label.pack(anchor=tk.W, pady=5)
        
        # Output directory selection
        output_dir_frame = ttk.Frame(config_frame)
        output_dir_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(output_dir_frame, text="Output Directory:").pack(side=tk.LEFT, padx=5)
        
        self.output_dir_var = tk.StringVar()
        output_entry = ttk.Entry(output_dir_frame, textvariable=self.output_dir_var, width=50)
        output_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        select_output_btn = ttk.Button(output_dir_frame, text="Browse", 
                                     command=self.select_output_directory)
        select_output_btn.pack(side=tk.LEFT, padx=5)
        
        # Additional options
        options_frame = ttk.Frame(config_frame)
        options_frame.pack(fill=tk.X, pady=5)
        
        # Combine output option
        self.combine_output_var = tk.BooleanVar(value=False)
        combine_check = ttk.Checkbutton(options_frame, text="Combine all files into one output", 
                                      variable=self.combine_output_var)
        combine_check.pack(side=tk.LEFT, padx=5)
        
        # Open output directory option
        self.open_output_var = tk.BooleanVar(value=True)
        open_check = ttk.Checkbutton(options_frame, text="Open output when finished", 
                                   variable=self.open_output_var)
        open_check.pack(side=tk.LEFT, padx=5)
        
        # Conversion control buttons
        control_frame = ttk.Frame(config_frame)
        control_frame.pack(fill=tk.X, pady=10)
        
        self.convert_btn = ttk.Button(control_frame, text="Convert Selected Files", 
                                    command=self.convert_selected_files, style="Accent.TButton")
        self.convert_btn.pack(side=tk.LEFT, padx=5)
        
        self.cancel_btn = ttk.Button(control_frame, text="Cancel", 
                                   command=self.cancel_conversion, state=tk.DISABLED)
        self.cancel_btn.pack(side=tk.LEFT, padx=5)
        
        # Conversion log
        log_frame = ttk.LabelFrame(main_frame, text="Conversion Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Progress bar
        self.progress_frame = ttk.Frame(log_frame)
        self.progress_frame.pack(fill=tk.X, pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(self.progress_frame, orient=tk.HORIZONTAL, 
                                         length=100, mode='determinate', 
                                         variable=self.progress_var)
        self.progress_bar.pack(fill=tk.X, side=tk.LEFT, expand=True)
        
        self.status_label = ttk.Label(self.progress_frame, text="Ready")
        self.status_label.pack(side=tk.LEFT, padx=5)
        
        # Log text area
        self.log_text = scrolledtext.ScrolledText(log_frame, height=10, state="disabled")
        self.log_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Set up custom logging
        self.log_handler = LoggingHandler(self.log_text)
        self.log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(self.log_handler)
        
        logger.info("MD to HTML converter tab initialized")
    
    def convert_selected_files(self):
        """Process the files selected in the main library panel for MD to HTML conversion."""
        # Get files selected in the main library panel
        selected_files = []
        
        if hasattr(self.parent, "file_tree") and self.parent.file_tree:
            for item_id in self.parent.file_tree.selection():
                item_values = self.parent.file_tree.item(item_id, "values")
                if item_values and len(item_values) > 1:
                    path = item_values[0]
                    item_type = item_values[1] if len(item_values) > 1 else ""
                    
                    # Only process markdown files, not directories
                    if item_type != "directory" and os.path.isfile(path) and path.lower().endswith(".md"):
                        selected_files.append(path)
        
        # Update the files to convert
        self.files_to_convert = selected_files
        self.update_file_list()
        
        # Check if any markdown files were selected
        if not self.files_to_convert:
            messagebox.showinfo("No Markdown Files", "Please select markdown (.md) files in the library panel first.")
            return
        
        # Get output directory
        output_dir = self.output_dir_var.get().strip()
        if not output_dir:
            # Default to the same directory as the first file
            output_dir = os.path.dirname(self.files_to_convert[0])
            self.output_dir_var.set(output_dir)
        
        self.output_dir = output_dir
        
        # Start the conversion
        self.start_conversion()
    
    def update_file_list(self):
        """Update the file count label."""
        self.file_count_label.config(text=f"{len(self.files_to_convert)} files selected for conversion")
    
    def select_output_directory(self):
        """Open directory dialog to select output directory"""
        output_dir = filedialog.askdirectory(title="Select Output Directory")
        if output_dir:
            self.output_dir_var.set(output_dir)
    
    def start_conversion(self):
        """Start the batch conversion process"""
        # Check if files are selected
        if not self.files_to_convert:
            messagebox.showinfo("No Files Selected", "Please select files to convert.")
            return
        
        # Check output directory
        output_dir = self.output_dir_var.get()
        if not output_dir:
            messagebox.showinfo("No Output Directory", "Please select an output directory.")
            return
        
        # Create output directory if it doesn't exist
        if not os.path.exists(output_dir):
            try:
                os.makedirs(output_dir)
            except Exception as e:
                messagebox.showerror("Error", f"Could not create output directory: {str(e)}")
                return
        
        # Get options
        combine_output = self.combine_output_var.get()
        open_output = self.open_output_var.get()
        
        # Update UI
        self.is_converting = True
        self.convert_btn.config(state=tk.DISABLED)
        self.cancel_btn.config(state=tk.NORMAL)
        self.progress_bar["value"] = 0
        self.update_status("Starting conversion...")
        
        # Clear log
        self.log_text.config(state=tk.NORMAL)
        self.log_text.delete(1.0, tk.END)
        self.log_text.config(state=tk.DISABLED)
        
        # Start conversion thread
        self.conversion_thread = threading.Thread(
            target=self.run_conversion,
            args=(self.files_to_convert.copy(), output_dir, combine_output, open_output),
            daemon=True
        )
        self.conversion_thread.start()
    
    def run_conversion(self, files, output_dir, combine_output, open_output):
        """Run the batch conversion process in a separate thread"""
        try:
            # Initialize
            total_files = len(files)
            successful = 0
            failed = 0
            combined_html = ""
            combined_filename = f"combined_markdown_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            
            self.update_status(f"Converting {total_files} files...")
            
            for i, file_path in enumerate(files):
                # Check if conversion was cancelled
                if not self.is_converting:
                    self.update_status("Conversion cancelled")
                    break
                
                try:
                    # Update progress
                    progress_pct = (i / total_files) * 100
                    self.update_progress(progress_pct)
                    
                    # Get file name and content
                    file_name = os.path.basename(file_path)
                    self.update_status(f"Converting ({i+1}/{total_files}): {file_name}")
                    
                    # Read markdown content
                    with open(file_path, 'r', encoding='utf-8') as f:
                        markdown_content = f.read()
                    
                    # Convert to HTML
                    html_content = markdown_to_html(markdown_content)
                    
                    # Handle output based on mode
                    if combine_output:
                        # Add a separator if not the first file
                        if combined_html:
                            combined_html += "<hr style='margin:40px 0;'>\n"
                        
                        # Add file name as heading if multiple files
                        if total_files > 1:
                            file_title = os.path.splitext(file_name)[0]
                            combined_html += f"<h2 style='margin-top:30px;'>File: {file_title}</h2>\n"
                        
                        combined_html += html_content
                    else:
                        # Create individual HTML file
                        out_file_name = os.path.splitext(file_name)[0] + ".html"
                        out_path = os.path.join(output_dir, out_file_name)
                        
                        with open(out_path, 'w', encoding='utf-8') as f:
                            f.write(html_content)
                        
                        self.update_status(f"Converted: {file_path} -> {out_path}")
                        logger.info(f"Converted: {file_path} -> {out_path}")
                    
                    successful += 1
                    
                except Exception as e:
                    failed += 1
                    error_msg = str(e)
                    trace = traceback.format_exc()
                    self.update_status(f"Error converting {file_name}: {error_msg}")
                    logger.error(f"Error converting {file_name}: {error_msg}\n{trace}")
            
            # Save combined HTML if selected
            if combine_output and combined_html and self.is_converting:
                combined_path = os.path.join(output_dir, combined_filename)
                with open(combined_path, 'w', encoding='utf-8') as f:
                    # Wrap in HTML document structure
                    doc = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Combined Markdown Files</title>
</head>
<body>
{combined_html}
</body>
</html>"""
                    f.write(doc)
                
                self.update_status(f"Combined output saved to: {combined_path}")
                logger.info(f"Combined output saved to: {combined_path}")
            
            # Update final status
            self.update_progress(100)
            
            if self.is_converting:  # Only show completion if not cancelled
                if failed > 0:
                    self.update_status(f"Conversion completed with {successful} successful and {failed} failed")
                else:
                    self.update_status(f"Successfully converted {successful} files")
                
                # Open output directory if requested
                if open_output and os.path.exists(output_dir):
                    try:
                        os.startfile(output_dir)
                    except:
                        # Fallback for different OS
                        try:
                            import subprocess
                            subprocess.Popen(['xdg-open', output_dir])
                        except:
                            pass
            
            # Reset UI on main thread
            self.parent.after(100, self.reset_ui)
            
        except Exception as e:
            error_msg = str(e)
            trace = traceback.format_exc()
            self.update_status(f"Conversion process failed: {error_msg}")
            logger.error(f"Conversion process failed: {error_msg}\n{trace}")
            self.parent.after(100, self.reset_ui)
    
    def update_status(self, message):
        """Update status label from any thread"""
        logger.info(message)
        self.parent.after(0, lambda: self.status_label.config(text=message))
    
    def update_progress(self, value):
        """Update progress bar from any thread"""
        self.parent.after(0, lambda: self.progress_var.set(value))
    
    def reset_ui(self):
        """Reset UI after conversion"""
        self.is_converting = False
        self.convert_btn.config(state=tk.NORMAL)
        self.cancel_btn.config(state=tk.DISABLED)
    
    def cancel_conversion(self):
        """Cancel the ongoing batch conversion"""
        if not self.is_converting:
            return
        
        self.is_converting = False
        self.update_status("Cancelling conversion...")
        logger.info("Conversion cancelled by user")


class FileRenamerPanel:
    """Handles file renaming functionality for standardizing markdown filenames."""
    
    def __init__(self, parent):
        """
        Initialize the file renamer panel.
        
        Args:
            parent: The parent ClaudeAIPanel instance
        """
        self.parent = parent
        self.is_renaming = False
        self.files_to_rename = []
        self.rename_thread = None
        self.preview_data = []
    
    def setup_renamer_tab(self):
        """Set up the file renamer tab."""
        tab = self.parent.file_renamer_tab
        
        # Main frame for all controls
        main_frame = ttk.Frame(tab, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title label
        title_label = ttk.Label(main_frame, text="Standardize File Names", font=("Arial", 12, "bold"))
        title_label.pack(pady=(10, 15))
        
        # Configuration frame
        config_frame = ttk.LabelFrame(main_frame, text="Renaming Settings", padding=10)
        config_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Instructions
        instructions = ttk.Label(config_frame, 
                           text="Select markdown files in the library panel and click 'Preview Rename' to see the new standardized filenames.")
        instructions.pack(anchor="w", padx=5, pady=5)
        
        # File count status
        self.file_count_label = ttk.Label(config_frame, text="0 files selected for renaming")
        self.file_count_label.pack(anchor=tk.W, pady=5)
        
        # Additional options
        options_frame = ttk.Frame(config_frame)
        options_frame.pack(fill=tk.X, pady=5)
        
        # Backup option
        self.create_backup_var = tk.BooleanVar(value=True)
        backup_check = ttk.Checkbutton(options_frame, text="Create backup of original files", 
                                      variable=self.create_backup_var)
        backup_check.pack(side=tk.LEFT, padx=5)
        
        # Renaming control buttons
        control_frame = ttk.Frame(config_frame)
        control_frame.pack(fill=tk.X, pady=10)
        
        self.preview_btn = ttk.Button(control_frame, text="Preview Rename", 
                                    command=self.preview_rename_files)
        self.preview_btn.pack(side=tk.LEFT, padx=5)
        
        self.rename_btn = ttk.Button(control_frame, text="Apply Rename", 
                                    command=self.rename_files, state=tk.DISABLED, style="Accent.TButton")
        self.rename_btn.pack(side=tk.LEFT, padx=5)
        
        self.cancel_btn = ttk.Button(control_frame, text="Cancel", 
                                   command=self.cancel_renaming, state=tk.DISABLED)
        self.cancel_btn.pack(side=tk.LEFT, padx=5)
        
        # Preview frame
        preview_frame = ttk.LabelFrame(main_frame, text="Rename Preview", padding=10)
        preview_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create a treeview for the preview
        self.preview_tree = ttk.Treeview(preview_frame, columns=("Original", "New"), show="headings")
        self.preview_tree.heading("Original", text="Original Filename")
        self.preview_tree.heading("New", text="New Filename")
        self.preview_tree.column("Original", width=300)
        self.preview_tree.column("New", width=300)
        self.preview_tree.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        # Add scrollbar to treeview
        scrollbar = ttk.Scrollbar(preview_frame, orient=tk.VERTICAL, command=self.preview_tree.yview)
        scrollbar.pack(fill=tk.Y, side=tk.RIGHT)
        self.preview_tree.configure(yscrollcommand=scrollbar.set)
        
        # Log frame for output
        log_frame = ttk.LabelFrame(main_frame, text="Renaming Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Progress bar
        self.progress_frame = ttk.Frame(log_frame)
        self.progress_frame.pack(fill=tk.X, pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(self.progress_frame, orient=tk.HORIZONTAL, 
                                         length=100, mode='determinate', 
                                         variable=self.progress_var)
        self.progress_bar.pack(fill=tk.X, side=tk.LEFT, expand=True)
        
        self.status_label = ttk.Label(self.progress_frame, text="Ready")
        self.status_label.pack(side=tk.LEFT, padx=5)
        
        # Log text area
        self.log_text = scrolledtext.ScrolledText(log_frame, height=8, state="disabled")
        self.log_text.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Set up custom logging
        self.log_handler = LoggingHandler(self.log_text)
        self.log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(self.log_handler)
        
        logger.info("File renamer tab initialized")
    
    def extract_module_info(self, file_path):
        """Extract module number and title from the markdown file."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read(500)  # Read just the beginning of the file
            
            # Look for module number (e.g., # 2.12)
            module_number = None
            module_title = None
            
            # Match a line starting with # followed by a number (possibly with decimal)
            number_match = re.search(r'^#\s*(\d+(?:\.\d+)?)', content, re.MULTILINE)
            if number_match:
                module_number = number_match.group(1).strip()
            
            # Look for the next heading, which should be the title
            # This could be either a second level-1 heading or a level-2 heading
            title_match = re.search(r'^#\s+([^#\n]+)$', content, re.MULTILINE)
            if title_match:
                # Find all level-1 headings
                all_h1 = re.findall(r'^#\s+([^#\n]+)$', content, re.MULTILINE)
                if len(all_h1) > 1:
                    # If there's more than one level-1 heading, the second one is likely the title
                    module_title = all_h1[1].strip()
                else:
                    # Otherwise, look for a level-2 heading
                    h2_match = re.search(r'^##\s+([^#\n]+)$', content, re.MULTILINE)
                    if h2_match:
                        module_title = h2_match.group(1).strip()
            
            return module_number, module_title
        except Exception as e:
            logger.error(f"Error extracting module info from {file_path}: {str(e)}")
            return None, None
    
    def generate_standard_filename(self, module_number, module_title, original_path):
        """Generate a standardized filename from module info."""
        if not module_number or not module_title:
            return None
        
        # Format module number with padded zeros for single-digit decimal parts
        # Example: 2.9 becomes 2.09, but 2.10 remains 2.10
        if '.' in module_number:
            base, decimal = module_number.split('.', 1)
            if decimal.isdigit() and len(decimal) == 1:
                module_number = f"{base}.{decimal.zfill(2)}"
        
        # Clean up the title: remove special characters, replace spaces with underscores
        clean_title = re.sub(r'[^\w\s-]', '', module_title)  # Remove special chars
        clean_title = re.sub(r'\s+', '_', clean_title)  # Replace spaces with underscores
        
        # Get the original file extension
        _, ext = os.path.splitext(original_path)
        
        # Create the standardized filename
        return f"{module_number}_{clean_title}{ext}"
    
    def preview_rename_files(self):
        """Preview the renaming of selected files."""
        # Get files selected in the main library panel
        selected_files = []
        
        if hasattr(self.parent, "file_tree") and self.parent.file_tree:
            for item_id in self.parent.file_tree.selection():
                item_values = self.parent.file_tree.item(item_id, "values")
                if item_values and len(item_values) > 1:
                    path = item_values[0]
                    item_type = item_values[1] if len(item_values) > 1 else ""
                    
                    # Only process markdown files, not directories
                    if item_type != "directory" and os.path.isfile(path) and path.lower().endswith(".md"):
                        selected_files.append(path)
        
        # Update the files to rename
        self.files_to_rename = selected_files
        self.update_file_list()
        
        # Check if any markdown files were selected
        if not self.files_to_rename:
            messagebox.showinfo("No Markdown Files", "Please select markdown (.md) files in the library panel first.")
            return
        
        # Clear previous preview
        self.preview_tree.delete(*self.preview_tree.get_children())
        self.preview_data = []
        
        # Generate preview data
        for file_path in self.files_to_rename:
            original_name = os.path.basename(file_path)
            module_number, module_title = self.extract_module_info(file_path)
            
            if module_number and module_title:
                new_name = self.generate_standard_filename(module_number, module_title, file_path)
                if new_name:
                    self.preview_data.append((file_path, original_name, new_name))
                    self.preview_tree.insert("", tk.END, values=(original_name, new_name))
                else:
                    self.preview_tree.insert("", tk.END, values=(original_name, "<Failed to generate name>"))
            else:
                self.preview_tree.insert("", tk.END, values=(original_name, "<Could not extract module info>"))
        
        # Update UI
        if self.preview_data:
            self.rename_btn.config(state=tk.NORMAL)
            self.update_status(f"Preview complete. {len(self.preview_data)} files ready to rename.")
        else:
            self.rename_btn.config(state=tk.DISABLED)
            self.update_status("No valid files to rename found.")
    
    def rename_files(self):
        """Start the file renaming process."""
        # Check if we have preview data
        if not self.preview_data:
            messagebox.showinfo("No Files", "Please preview files before renaming.")
            return
        
        # Update UI
        self.is_renaming = True
        self.preview_btn.config(state=tk.DISABLED)
        self.rename_btn.config(state=tk.DISABLED)
        self.cancel_btn.config(state=tk.NORMAL)
        self.progress_bar["value"] = 0
        self.update_status("Starting renaming...")
        
        # Clear log
        self.log_text.config(state=tk.NORMAL)
        self.log_text.delete(1.0, tk.END)
        self.log_text.config(state=tk.DISABLED)
        
        # Get backup option
        create_backup = self.create_backup_var.get()
        
        # Start renaming thread
        self.rename_thread = threading.Thread(
            target=self.run_renaming,
            args=(self.preview_data.copy(), create_backup),
            daemon=True
        )
        self.rename_thread.start()
    
    def run_renaming(self, rename_data, create_backup):
        """Run the file renaming process in a separate thread."""
        try:
            # Initialize variables
            total_files = len(rename_data)
            successful = 0
            
            logger.info(f"Starting renaming of {total_files} files")
            logger.info(f"Create backup: {create_backup}")
            
            # Process each file
            for i, (file_path, original_name, new_name) in enumerate(rename_data):
                # Check if renaming was cancelled
                if not self.is_renaming:
                    logger.info("Renaming cancelled")
                    break
                
                try:
                    # Update status
                    self.update_status(f"Renaming {i+1}/{total_files}: {original_name}")
                    self.update_progress((i / total_files) * 100)
                    
                    logger.info(f"Processing: {file_path}")
                    
                    # Get directory and create new path
                    directory = os.path.dirname(file_path)
                    new_path = os.path.join(directory, new_name)
                    
                    # Check if target already exists
                    if os.path.exists(new_path) and new_path != file_path:
                        logger.warning(f"Destination file already exists: {new_path}")
                        continue
                    
                    # Skip if the new name is the same as the original
                    if original_name == new_name:
                        logger.info(f"Skipping {file_path} - name already standardized")
                        successful += 1
                        continue
                    
                    # Create backup if requested
                    if create_backup:
                        backup_path = file_path + ".bak"
                        shutil.copy2(file_path, backup_path)
                        logger.info(f"Created backup: {backup_path}")
                    
                    # Rename the file
                    os.rename(file_path, new_path)
                    logger.info(f"Renamed: {original_name} → {new_name}")
                    
                    successful += 1
                    
                except Exception as e:
                    logger.error(f"Error processing {file_path}: {str(e)}")
                    logger.error(traceback.format_exc())
            
            # Update UI
            if self.is_renaming:
                self.update_status(f"Renaming complete. {successful}/{total_files} files renamed successfully.")
                self.update_progress(100)
                logger.info(f"Renaming complete. {successful}/{total_files} files renamed successfully.")
                
                # Show completion message
                self.parent.after(0, lambda: messagebox.showinfo(
                    "Renaming Complete", 
                    f"{successful}/{total_files} files renamed successfully."
                ))
                
                # Refresh the file tree after renaming
                if hasattr(self.parent, "refresh_file_tree"):
                    self.parent.after(500, self.parent.refresh_file_tree)  # Slight delay to ensure files are updated
        
        except Exception as e:
            logger.error(f"Error during renaming: {str(e)}")
            logger.error(traceback.format_exc())
            self.update_status(f"Error: {str(e)}")
            
            # Show error message
            self.parent.after(0, lambda: messagebox.showerror(
                "Renaming Error", 
                f"An error occurred during renaming: {str(e)}"
            ))
        
        finally:
            # Reset UI
            self.parent.after(0, self.reset_ui)
    
    def update_file_list(self):
        """Update the file count label."""
        self.file_count_label.config(text=f"{len(self.files_to_rename)} files selected for renaming")
    
    def update_status(self, message):
        """Update status label from any thread."""
        self.parent.after(0, lambda: self.status_label.config(text=message))
        self.parent.update_status(message)
    
    def update_progress(self, value):
        """Update progress bar from any thread."""
        self.parent.after(0, lambda: self.progress_bar.config(value=value))
    
    def reset_ui(self):
        """Reset UI after renaming."""
        self.is_renaming = False
        self.preview_btn.config(state=tk.NORMAL)
        self.rename_btn.config(state=tk.DISABLED)
        self.cancel_btn.config(state=tk.DISABLED)
    
    def cancel_renaming(self):
        """Cancel the ongoing renaming process."""
        if self.is_renaming:
            self.is_renaming = False
            self.update_status("Cancelling renaming...")
            logger.info("User cancelled renaming")
